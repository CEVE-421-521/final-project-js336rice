---
title: "Final Project Report"
author: "Jonah Schaechter (JS336)"
jupyter: julia-1.10
date: 2024-04-30

# YOU DO NOT NEED BOTH PDF AND DOCX.
# COMMENT OR DELETE THE ONE YOU DON'T WANT TO USE.
#
# Feel free to customize the look of your final document:
# https://quarto.org/docs/reference/formats/pdf.html
# https://quarto.org/docs/reference/formats/docx.html

format: 
    pdf:
        documentclass: article
        fontsize: 11pt
        geometry:
            - margin=1in  
        number-sections: true
        code-line-numbers: true
    # docx: 
    #    toc: true
    #    fig-format: png
    #    number-sections: true
    #    code-line-numbers: true

date-format: "ddd., MMM. D"

# See Quarto docs: https://quarto.org/docs/authoring/footnotes-and-citations.html
# you can export your references from Zotero, EndNote, or other reference managers
# from Zotero you'll need https://retorque.re/zotero-better-bibtex/
references: references.bib

# recommended, but not required
# you will need jupyter-cache installed
execute: 
  cache: true
---

# Introduction

## Problem Statement

So far, our simulations have considered the Net Present Value of home elevation under the assumption that homeowners will pay for their home elevation out of pocket.  In reality, people have to chose between paying out of pocket (if this is even something they can afford), taking out a loan, or saving up.  

Each of these options has tradeoffs in total cost, yearly cost, the cost of damages,and in NPV.  In this paper, we will analize these tradeoffs. 

## Selected Feature

Describe the feature you have selected to add to the existing decision-support tool.
Discuss how this feature relates to the problem statement and its potential to improve climate risk assessment.

# Literature Review

Provide a brief overview of the theoretical background related to your chosen feature.
Cite at least two relevant journal articles to support your approach (see [Quarto docs](https://quarto.org/docs/authoring/footnotes-and-citations.html) for help with citations).
Explain how these articles contribute to the justification of your selected feature.

# Methodology

## Implementation

```{julia}
import Pkg 
Pkg.status()  # Note the paths for your local packages
Pkg.gc()  # Garbage collect and delete cached package files
```


```{julia}
using CSV
using DataFrames
using DataFramesMeta
using Distributions
using LaTeXStrings
using Metaheuristics
using Plots
using Random
using Unitful

Plots.default(; margin=5Plots.mm)
```

```{julia}
using Revise
using HouseElevation
#include("Finance.jl")
#using house
```

We put in our house in galveston

Choosing Galveston Pier 21, Texas
The guage is at 29° 18.6 N, 94° 47.6 W
https://maps.app.goo.gl/GyanSMA2fp9rkVrT9

Our building is 302 17th St, Galveston, TX 77550,
Home area as estimated by google maps: 30ftx50ft home = 1500ft^2
Home value from zillow: 247,700 (Round up to 250,000)

The home is 4.41 feet or 1.34 meters above sea level in elevation.
Looking at it on street view, the house appears to be on concrete blocks about 6 inches tall, giving it an effective height of 4.91 feet.  Round this up to 5 so that it works.

Row 98 from the data is two-story, no basement in Galveston, so we'll be using that for our depth-damage curve.  The home is on concrete blocks, so we can be confident that it doesn't have a basement.



```{julia}
#| output: false
house = let
    haz_fl_dept = CSV.read("data/haz_fl_dept.csv", DataFrame) # read in the file
    desc = "Two-story, no basement in Galveston"
    row = @rsubset(haz_fl_dept, :Column1 == 98)[1, :,] # select the row I want
    area = 1500u"ft^2"
    height_above_gauge = height_above_gauge = 5u"ft"  
    House(row; area=area, height_above_gauge=height_above_gauge, value_usd=250_000)
end
```


```{julia}
#| output: false
slr_scenarios = let
    df = CSV.read("data/slr_oddo.csv", DataFrame)
    [Oddo17SLR(a, b, c, tstar, cstar) for (a, b, c, tstar, cstar) in eachrow(df)]
end

function draw_surge_distribution()
    μ = rand(Normal(5, 1))
    σ = rand(Exponential(1.25))
    ξ = rand(Normal(0.1, 0.05))
    return GeneralizedExtremeValue(μ, σ, ξ)
end

function draw_discount_rate()
    return rand(Normal(0.05, 0.03))
end

function draw_sow()
    slr = rand(slr_scenarios)
    surge_params = draw_surge_distribution()
    discount = draw_discount_rate()
    return SOW(slr, surge_params, discount)
end
```

Generate our possible states of the world

```{julia}
Random.seed!(421521)
N_SOW = 10
N_SOW_opt = 50 # to start
sows = [draw_sow() for _ in 1:N_SOW]
sows_opt = first(sows, N_SOW_opt)


```


Write our function we'll use to evaluate financial plans 


```{julia}

p = ModelParams(; house=house, years=2024:2083, finance=finance_basic)  #make our model 

elevations_try = 0:0.5:14  #establish actions to try 
actions_try = Action.(elevations_try)

#Get all the contruction costs we can afford
construction_costs = [elevation_cost(house, elevation) for elevation in elevations_try if elevation_cost(house, elevation) <= 170_000]

actions_try = actions_try[1:length(construction_costs)]  #get the list of actions we can afford


```


```{julia}

#assume physical house and SLR scenarios stay constant, only financial conditions change
function financial_npvs(finance)
    p = ModelParams(; house=house, years=2024:2083, finance=finance)  #make our model 

    elevations_try = 0:0.5:14  #establish actions to try 
    actions_try = Action.(elevations_try)

    #Get all the contruction costs we can afford
    construction_costs = [elevation_cost(house, elevation) for elevation in elevations_try if elevation_cost(house, elevation) <= p.finance.amnt_paid_off]

    actions_try = actions_try[1:length(construction_costs)]  #get the list of actions we can afford
    elevations_try = elevations_try[1:length(construction_costs)]  #limit elevations as well since we output this later

    #Run simulations 
    npvs_opt = [mean([run_sim(a, sow, p) for sow in sows_opt]) for a in actions_try]  

    #get height that minimizes NPV
    min_npv, min_idx = findmax(npvs_opt)
    minimizer = elevations_try[min_idx]

    #return elevations we tried (x), npvs(y) and minimizing elevation 
    return elevations_try, npvs_opt, minimizer

end

```

Basic financing, just paying up fronts


println(methods(Finance))
println(fieldtypes(Finance))


```{julia}


finance_basic = let
    loan = 0
    loan_years = 0
    loan_rate = 0.0
    paid_off_percent = 1.0
    amnt_paid_off = paid_off_percent * house.value_usd  # Calculate amnt_paid_off

    # Create Finance object using keyword arguments
    Finance(;
        loan = loan,
        loan_years = loan_years,
        loan_rate = loan_rate,
        paid_off_percent = paid_off_percent,
        amnt_paid_off = amnt_paid_off
    )
end
```


Now lets calculate our basic finance options

```{julia}

elevations_tried, npvs, min = financial_npvs(finance_basic)

```


Define our function to plot many financial scenarios 

```{julia}
function plot_many(finance_list, initial_plot)

    
    for finance in finance_list
       
        #println(finance)
        elevations_tried, npvs, min = financial_npvs(finance)
        if finance.loan == 1  #if taking out a loan
            label = "$(round(finance.loan_rate*100))% loan over $(finance.loan_years) years"
        elseif finance.loan > 1
            label = "Saving over $(finance.loan_years) years"
        else 
            label = "Paying out of pocket"
        end
        plot!(
        initial_plot,
        elevations_tried,
        npvs ./ 1000;
        xlabel="Elevation [ft]",
        ylabel="NPV [1000 USD]",
        label=label,
        marker=:circle,
        #color=line_color
        )

         #make the vertical line color the same as the horizontal line
        line_color = initial_plot.series_list[end][:linecolor]
        #line_color = plot_object.series_list[end].plotseries[:linecolor] 
        vline!([min]; label="$(min)ft elevation", linestyle=:dash, color=line_color)
    end
end

```



Generate many financial scenarios where we save up for different periods of time


```{julia}

finance_saving = []

for i in [2, 3, 5, 7]
    #print(i)
    paid_off_percent = 1.0
    fin = Finance(; loan=2, loan_years=i, loan_rate=0.0, paid_off_percent=paid_off_percent,
        amnt_paid_off=(house.value_usd*paid_off_percent)
        )
    push!(finance_saving, fin)
end

println(finance_saving)
```

Plot our saving options

```{julia}

p = plot(
    elevations_tried,
    npvs ./ 1000;
    xlabel="Elevation [ft]",
    ylabel="NPV [1000 USD]",
    title="Out of Pocket Vs Various saving periods",
    label="Out of pocket",
    marker=:circle#, color=line_color
)


line_color = p.series_list[end][:linecolor]  #make the vertical line color the same as the horizontal line
vline!([min]; label="$(min)ft elevation", linestyle=:dash, color=line_color)

plot_many(finance_saving, p)
display(p)

```

Results of this graph show two interesting things:

1. NPV of saving is always a lot lower than paying up front.  This makes sense, since we're increasing construction cost with inflation, so the only change to the NPV will be more damages while we wait to elevate the house.

2. NPV results recommend lower elevations if we chose to wait.  This seems strange at first, since most people might save money so they can elevate higher, and you'd think that if we do wait to elevate, it'd make more sense to do a higher elevation to compensate for the damages we experienced in the first few years.  

But since we are doing this simulation over a fixed period of time, the longer we wait to elevate, the less value is gained by elevating, since we'll have spent less of our time avoiding damages.  So assuming a non-infinite time duration for this experiment, the longer we wait to elevate, the lower the recommended elevation height gets.  

We can demonstrate this more clearly by displaying some extremely long saving periods.



```{julia}

Long_Savings = []

for i in [10, 20, 30, 50]
    #print(i)
    paid_off_percent = 1.0
    fin = Finance(; loan=2, loan_years=i, loan_rate=0.0, paid_off_percent=paid_off_percent,
        amnt_paid_off=(house.value_usd*paid_off_percent)
        )
    push!(Long_Savings, fin)
end

println(Long_Savings)
```

```{julia}

p = plot(
    elevations_tried,
    npvs ./ 1000;
    xlabel="Elevation [ft]",
    ylabel="NPV [1000 USD]",
    title="Out of Pocket Vs Various saving periods",
    label="Out of pocket",
    marker=:circle#, color=line_color
)


line_color = p.series_list[end][:linecolor]  #make the vertical line color the same as the horizontal line
vline!([min]; label="$(min)ft elevation", linestyle=:dash, color=line_color)

plot_many(Long_Savings, p)
display(p)

```



Generate many financial scenarios with different years to pay off the loan at a 7% interest rate

```{julia}

finance_list_years = []

for i in [3, 5, 7, 10]
    #print(i)
    paid_off_percent = 0.7
    fin = Finance(; loan=1, loan_years=i, loan_rate=0.07, paid_off_percent=paid_off_percent,
        amnt_paid_off=(house.value_usd*paid_off_percent)
        )
    push!(finance_list_years, fin)
end

println(finance_list_years)
```

Plot our scenarios of different years to pay off the loan 

```{julia}

p = plot(
    elevations_tried,
    npvs ./ 1000;
    xlabel="Elevation [ft]",
    ylabel="NPV [1000 USD]",
    title="Out of Pocket Vs Various payment periods",
    label="First $(N_SOW_opt) SOWs, no loan",
    marker=:circle#, color=line_color
)


line_color = p.series_list[end][:linecolor]  #make the vertical line color the same as the horizontal line
vline!([min]; label="$(min)ft elevation", linestyle=:dash, color=line_color)

plot_many(finance_list_years, p)
display(p)

```


Generate many financial scenarios with different interest rates

```{julia}

finance_list_rates = []

for i in range(start=3, stop=9, length=4)
    #print(i)
    paid_off_percent = 0.7
    fin = Finance(; loan=1, loan_years=5, loan_rate=i/100, paid_off_percent=paid_off_percent,
        amnt_paid_off=(house.value_usd*paid_off_percent)
        )
    push!(finance_list_rates, fin)
end

println(finance_list_rates)
```


```{julia}

#colors = [colorant"red", colorant"green", colorant"blue", colorant"orange", colorant"purple"]

#line_color = colors[1]

p = plot(
    elevations_tried,
    npvs ./ 1000;
    xlabel="Elevation [ft]",
    ylabel="NPV [1000 USD]",
    title="Out of Pocket Vs Various 5 year loans, 70% paid off",
    label="First $(N_SOW_opt) SOWs, no loan",
    marker=:circle#, color=line_color
)
#println(p.series_list[end][:linecolor] )

#colors = Plots.palette()

line_color = p.series_list[end][:linecolor]  #make the vertical line color the same as the horizontal line
vline!([min]; label="$(min)ft elevation", linestyle=:dash, color=line_color)

plot_many(finance_list_rates, p)
display(p)
```



```{julia}
bounds = boxconstraints(; lb=[0.0], ub=[14.0])
```

```{julia}
function objective_function(Δh::Vector{Float64})
    a = Action(Δh[1])
    npvs = [run_sim(a, sow, p) for sow in sows_opt]
    return -mean(npvs)
end

#function house_objective(Δh::Vector{Float64}, house) #objective function for that house

```

```{julia}
result = optimize(objective_function, bounds)
```

We can view the minimum of the objective function with

```{julia}
display(minimum(result))
display(minimizer(result))
```


This seems like it's working plausibly.
Let's try now with more SOWs.

```{julia}
N_SOW_opt = 100
sows_opt = first(sows, N_SOW_opt)
```

Since I'm using more SOWs here, I'll also increase the time limit for the optimization to three minutes.

```{julia}
options = Options(; time_limit=180.0, f_tol_rel=10.0)
```

To use options, we have to choose an algorithm.
See list of algorithms [here](https://jmejia8.github.io/Metaheuristics.jl/stable/algorithms/).
The `ECA` algorithm is suggested as a default, so we'll use that.

```{julia}
algorithm = ECA(; options=options)
```

Before we run the optimization, let's set a random seed.

```{julia}
Random.seed!(421521)
result = optimize(objective_function, bounds, algorithm)
```
```{julia}
display(minimum(result))
display(minimizer(result))
```




You should make your modifications in either the `HouseElevation` or `ParkingGarage` module.
Detail the steps taken to implement the selected feature and integrate it into the decision-support tool.
Include code snippets and explanations where necessary to clarify the implementation process.

## Validation

In this case, we don't really _need_ optimization -- we can use brute force.
We can compare by plotting the objective function for a range of elevations (from 0 to 14 ft) using all SOWs.



and plot

```{julia}
plot(
    elevations_try,
    npvs_opt ./ 1000;
    xlabel="Elevation [ft]",
    ylabel="NPV [1000 USD]",
    label="First $(N_SOW_opt) SOWs",
    marker=:circle,
)
plot!(elevations_try, npvs_moore ./ 1000; title="Out of Pocket Payment", label="First $(N_more) SOWs", marker=:circle)
vline!([minimizer(result)]; label="Optimal", linestyle=:dash)
```


As we have seen in labs, mistakes are inevitable and can lead to misleading results.
To minimize the risk of errors making their way into final results, it is essential to validate the implemented feature.
Describe the validation techniques used to ensure the accuracy and reliability of your implemented feature.
Discuss any challenges faced during the validation process and how they were addressed.

# Results

Present the results obtained from the enhanced decision-support tool.
Use tables, figures, and visualizations to clearly communicate the outcomes.
Provide sufficient detail to demonstrate how the implemented feature addresses the problem statement.
Use the `#| output: false` and/or `#| echo: false` tags to hide code output and code cells in the final report except where showing the output (e.g.g, a plot) or the code (e.g., how you are sampling SOWs) adds value to the discussion.
You may have multiple subsections of results, which you can create using `##`.

# Conclusions

## Discussion

Analyze the implications of your results for climate risk management.
Consider the context of the class themes and discuss how your findings contribute to the understanding of climate risk assessment.
Identify any limitations of your approach and suggest potential improvements for future work.

## Conclusions

Summarize the key findings of your project and reiterate the significance of your implemented feature in addressing the problem statement.
Discuss the broader implications of your work for climate risk management and the potential for further research in this area.

# References